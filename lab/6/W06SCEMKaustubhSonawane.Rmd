---
title: "Assignment 06 - Solutions"
subtitle: "Statistical Computing and Empirical Methods"
author: "Kaustubh Sonawane 2701553"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

## A word of advice

Think of the SCEM labs as going to the gym: if you pay a gym membership,
but instead of working out you use a machine to lift the weights for
you, you won't get the benefits.

ChatGPT, DeepSeek, Claude and other GenAI tools can provide answers to
most of the questions below. Before you try that, please consider the
following: answering the specific questions below is not the point of
this assignment. Instead, the questions are designed to give you the
chance to develop a better understanding of estimation concepts and a
certain level of ***statistical thinking***. These are essential skills
for any data scientist, even if they end up using generative AI - to
write an effective prompt and to catch the common (often subtle) errors
that AI produces when trying to solve anything non-trivial.

A very important part of this learning involves not having the answers
ready-made for you, but instead taking the time to actually search for
the answer, trying something, getting it wrong, and trying again.

So, make the best use of this session. The assignments are not marked,
so it is much better to try the yourself even if you get incorrect
answers (you'll be able to correct yourself later when you receive
feedback) than to submit a perfect, but GPT'd solution.

------------------------------------------------------------------------

## IMPORTANT NOTES:

-   **DO NOT** change the code block names. Enter your solutions to each
    question into the predefined code blocks.
-   **DO NOT** add calls to `install.packages()` into your solutions.
    Some questions may require you to load packages using `library()`.
    Please do not use any other packages except the ones explicitly
    listed in the "setup" code block.

------------------------------------------------------------------------

## Setup

This code block below sets up your session. The only think you should
change in it is to replace `"ABCDEFG"` by your student ID number, which
will be used as the seed for your random number generators.

```{r ID, echo=FALSE, message=FALSE, warning=FALSE}
## We will use your student ID as the seed for the random number generator.
MY_STUDENT_ID <- 2701553 # <-- Replace "ABCDEFG" by your student ID number (as an integer, i.e., without quotes).
```

```{r Setup, echo=FALSE, message=FALSE, warning=FALSE}
## DO NOT CHANGE ANYTHING IN THIS CODE BLOCK

## Note: tidyverse includes:
## ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats, and lubridate.
## You can load any of those packages, as needed

allowed.packages <- c("tidyverse", "NHANES", "multcomp", "MKpower",
                      "jsonlite", "jquerylib", "knitr", "rmarkdown")

for (i in seq_along(allowed.packages)){
  if(!(allowed.packages[i] %in% installed.packages()[, 1])){
    install.packages(allowed.packages[i], 
                     repos = "https://cloud.r-project.org")
                     # dependencies = c("Depends", "Imports", "Suggests"))
  }
}

knitr::opts_chunk$set(echo = TRUE, collapse=TRUE)
ignore <- runif(1) # To initialise the PRNG
```

```{r checkID, echo=FALSE}
if(!is.numeric(MY_STUDENT_ID)){
  stop("MY_STUDENT_ID MUST BE YOUR VALID NUMERIC ID.")
} 
```

## Q1: Warm up:

::: {#prompt .message style="color: blue;"}
**a.** Follow the instructions to create a data frame `bp.df`.
:::

```{r Q1a}
#' Required variables: bp.df (data.frame)
#' Required plots: NA
library(NHANES)
library(dplyr)
library(ggplot2)

data("NHANES")


bp.df = NHANES %>%
  filter(Age >= 25, Age <=30) %>%
  select(Gender, BPSysAve) %>%
  filter(!is.na(BPSysAve))  # %>%
  # filter(!is.na(Gender))

dim(bp.df)
```

::: {.message style="color: blue;"}
**b.** Generate the plot indicated in the assignment brief.
:::

```{r Q1b}
#' Required variables: NA
#' Required plots: violin+jittered plot

ggplot(bp.df) +
  geom_violin(aes(x = Gender, y = BPSysAve, fill = Gender), alpha = 0.5) +
  geom_jitter(aes(x = Gender, y = BPSysAve), width = 0.05) +
  theme_minimal() +
  ylab('Average Systolic Blood Pressure (mmHg)') +
  ggtitle('Blood Pressure') +
  labs(subtitle = '25 - 30 year old US residents; 2009 - 2012')

```

::: {.message style="color: blue;"}
**c.** Create the required dataframe `bp.marital`.
:::

```{r Q1c}
#' Required variables: bp.marital (data.frame); pval (numeric); ci95 (numeric)
#' Required plots: NA

bp.marital = NHANES %>%
  filter(Gender == "male") %>%
  filter(Age >= 30, Age <= 40) %>%
  filter(MaritalStatus %in% c("Married", "NeverMarried")) %>%
  select(MaritalStatus, BPSysAve) %>%
  filter(!is.na(BPSysAve))

dim(bp.marital)

# Method 1
bp.married = bp.marital$BPSysAve[bp.marital$MaritalStatus == 'Married']
bp.nevermarried = bp.marital$BPSysAve[bp.marital$MaritalStatus == 'NeverMarried']

tm1 = t.test(bp.married, bp.nevermarried, conf.level = 0.95)
tm1

# Method 2
tm2 = t.test(BPSysAve ~ MaritalStatus, data = bp.marital, conf.level = 0.95)
tm2

pval = tm1$p.value
ci95 = tm1$conf.int

pval
ci95


```

## Q2: A/B test power and subgroup analysis

::: {.message style="color: blue;"}
**a.** Load the required data frame and produce the boxplots.
:::

```{r Q2a}
#' Required variables: df.ab1 (data.frame)
#' Required plots: boxplots

df.ab1 = read.csv("session_ab_test.csv")

ggplot(df.ab1) +
  geom_boxplot(aes(x = age_band, y = session_duration_min, fill = group), alpha = 0.7)
```

::: {.message style="color: blue;"}
**b.** Add the new variable with the log-durations.
:::

```{r Q2b}
#' Required variables: df.ab1.log (data.frame)
#' Required plots: boxplots or violin plots

df.ab1.log = mutate(df.ab1, duration.log = log10(df.ab1$session_duration_min))

ggplot(df.ab1.log) +
  # geom_violin(aes(x = age_band, y = duration.log, fill = group), alpha = 0.7)
  geom_boxplot(aes(x = age_band, y = duration.log, fill = group), alpha = 0.7)
```

::: {.message style="color: blue;"}
**c.** Calculate the required sample size to get a set of tests with the
desired statistical properties.
:::

```{r Q2c}
#' Required variables: required_n_per_group (numeric)
#' Required plots: NA

required_n_per_group = power.t.test(
  delta = 0.08,
  sd = 0.3,
  power = 0.8,
  sig.level = 0.05/5,
  alternative = "one.sided"
)$n

required_n_per_group
```

::: {.message style="color: blue;"}
**d.** Produce the required summary data frame with the available sample
sizes.
:::

```{r Q2d}
#' Required variables: NA
#' Required plots: NA
table(df.ab1$group, df.ab1$age_band)
```

::: {.message style="color: blue;"}
**e.** Create the modified dataframe `df.ab1.log2`.
:::

```{r Q2e}
#' Required variables: df.ab1.log2 (data.frame)
#' Required plots: NA

df.ab1.log2 = mutate(df.ab1.log, new_age = ifelse(df.ab1.log$age_band < 35, "younger", "older"))
table(df.ab1.log2$new_age, df.ab1.log2$group)
```

::: {.message style="color: blue;"}
**f.** Perform the hypotheses tests and calculate the corrected
p-values.
:::

```{r Q2f}
#' Required variables: pvals.raw (numeric); pvals.holm (numeric)
#' Required plots: NA
younger = filter(df.ab1.log2, new_age == 'younger')
older = filter(df.ab1.log2, new_age == 'older')


ttest.younger = t.test(
  duration.log ~ group,
  data = younger,
  alternative = "greater",
  conf.level = 0.95
)

ttest.older = t.test(
  duration.log ~ group,
  data = older,
  alternative = "greater",
  conf.level = 0.95
)

# ttest.younger$p.value
# ttest.older$p.value

pvals.raw = c(ttest.younger$p.value, ttest.older$p.value)
pvals.holm = p.adjust(pvals.raw, method = "holm")

pvals.holm
```

## Q3: paired t test

::: {.message style="color: blue;"}
**a.** Load and prepare the data.
:::

```{r Q3a}
#' Required variables: df.paired.t (data.frame)
#' Required plots: NA

df.paired.t = readRDS("UPMSP_SA_full_results.rds")

df.paired.t = df.paired.t %>%
  group_by(Algorithm, Instance) %>%
  summarise(MeanMS = mean(Makespan)) %>%
  filter(Algorithm == 'Full' | Algorithm == 'no-2SH')


# dim(df.paired.t)
df.paired.t

```

::: {.message style="color: blue;"}
**b.** Formalise the test hypotheses
:::

::: {#Q3b .message style="color: black;"}
Defining $d_j = y_{(no2sh), j} - y_{(full), j}$, the hypotheses can be
written as: $$
\begin{cases}
H_0: \mu = 0\\
H_a: \mu_d > 0
\end{cases}
$$
:::

::: {.message style="color: blue;"}
**c.** Perform the paired t-test.
:::

```{r Q3c}
#' Required variables: pval.paired (numeric); diff.paired (numeric); ci.paired (numeric)
#' Required plots: NA


xpair <- df.paired.t$MeanMS[df.paired.t$Algorithm == "no-2SH"] -
  df.paired.t$MeanMS[df.paired.t$Algorithm == "Full"]

(mytest <- t.test(xpair, alternative = "greater"))

pval.paired = mytest$p.value
diff.paired = mytest$estimate
ci.paired = mytest$conf.int

pval.paired
diff.paired
ci.paired


# df.full = df.paired.t$MeanMS[df.paired.t$Algorithm == "Full"]
# df.no2SH = df.paired.t$MeanMS[df.paired.t$Algorithm == "no-2SH"]
# 
# ttest.paired = t.test(
#   # df.full,
#   df.paired.t$MeanMS[df.paired.t$Algorithm == "Full"],
#   # df.no2SH,
#   df.paired.t$MeanMS[df.paired.t$Algorithm == "no-2SH"],
#   # conf.level = 0.95,
#   alternative = 'greater',
#   paired = TRUE
#   )

# ttest.paired
# 
# pval.paired = ttest.paired$p.value
# diff.paired = ttest.paired$estimate
# ci.paired = ttest.paired$conf.int
# 
# pval.paired
# diff.paired
# ci.paired
```

::: {.message style="color: blue;"}
**d.** Ignore the pairing and run a simple t-test to see what comes out.
:::

```{r Q3d}
#' Required variables: NA
#' Required plots: NA

t.test(
  df.paired.t$MeanMS[df.paired.t$Algorithm == "Full"],
  df.paired.t$MeanMS[df.paired.t$Algorithm == "no-2SH"],
  alternative = "greater"
  )

```

## Q4: ANOVA

::: {.message style="color: blue;"}
**a.** Load the dataset and generate the data summary as instructed.
:::

```{r Q4a}
#' Required variables: df.strat (data.frame); df.strat.stats (data.frame)
#' Required plots: NA

df.strat = read.csv("business_strategies.csv")

dim(df.strat)

df.strat.stats = df.strat %>%
  group_by(strategy) %>%
  summarise(
    meanRev = mean(Revenue30Days),
    sdRev = sd(Revenue30Days),
    N = n()
  )

df.strat.stats

```

::: {.message style="color: blue;"}
**b.** Generate the faceted normal QQ-plots
:::

```{r Q4b}
#' Required variables: NA
#' Required plots: faceted qqplots

ggplot(df.strat) +
  geom_qq(aes(sample = Revenue30Days)) +
  geom_qq_line(aes(sample = Revenue30Days)) +
  facet_wrap(~strategy) +
  theme_light() +
  xlab("Normal Quantiles") +
  ylab("Revenue")
  theme(strip.text = element_text(colour = "black", face = "bold"))

```

::: {.message style="color: blue;"}
**c.** Perform the Fligner-Kileen test
:::

```{r Q4c}
#' Required variables: NA
#' Required plots: NA

# ?fligner.test()
fligner.test(Revenue30Days ~ strategy, data = df.strat)

```

::: {.message style="color: blue;"}
**d.** Perform the ANOVA
:::

```{r Q4d}
#' Required variables: aov.strat (aov)
#' Required plots: NA

aov.strat <- aov(Revenue30Days ~ strategy, data = df.strat)
summary(aov.strat)

```

::: {.message style="color: blue;"}
**e.** Update the dataframe `df.strat` and the anova object `aov.strat`,
then perform the post-ANOVA multiple testing using the sequential
contrast "Tukey".
:::

```{r Q4e}
#' Required variables: df.strat (data.frame); aov.strat (aov); strat.tukey (glht)
#' Required plots: NA
library(multcomp)

df.strat$strategy = as.factor(df.strat$strategy)

aov.strat = aov(data = df.strat, Revenue30Days ~ strategy)
summary(aov.strat)

strat.tukey = glht(aov.strat, linfct = mcp(strategy = "Tukey"))
summary(strat.tukey)
```

## Q5: Blocked ANOVA

::: {.message style="color: blue;"}
**a.** Load and prepare the data.
:::

```{r Q5a}
#' Required variables: df.cbd (data.frame)
#' Required plots: NA

df.cbd = readRDS("UPMSP_SA_full_results.rds")

df.cbd = df.cbd %>%
  group_by(Algorithm, Instance) %>%
  summarise(
    MeanMS = mean(Makespan)
  )

df.cbd$Algorithm = as.factor(df.cbd$Algorithm)
df.cbd$Instance = as.factor(df.cbd$Instance)
df.cbd

```

::: {.message style="color: blue;"}
**b.** Perform a blocked ANOVA test
:::

```{r Q5b}
#' Required variables: NA
#' Required plots: NA

blocked.aov = aov(data = df.cbd, MeanMS ~ Algorithm - Instance)

summary(blocked.aov)
blocked.aov
```

::: {.message style="color: blue;"}
**c.** Perform the Dunnett test to check which methods are significantly
different from the reference one.
:::

```{r Q5c}
#' Required variables: cbd.mht
#' Required plots: NA


cbd.mht = glht(aov.strat, linfct = mcp(strategy = "Dunnett"))
summary(cbd.mht)
```

::: {.message style="color: blue;"}
**d.** Generate the visualisation of the differences.
:::

```{r Q5d}
#' Required variables: NA
#' Required plots: confidence intervals


```
