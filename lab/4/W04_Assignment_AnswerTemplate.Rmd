---
title: "Assignment 03 - Solutions"
subtitle: "Statistical Computing and Empirical Methods"
author: "YOUR_NAME (YOUR_STUDENT_ID)"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

## A word of advice
Think of the SCEM labs as going to the gym: if you pay a gym membership, but instead of working out you use a machine to lift the weights for you, you won't get the benefits.

ChatGPT, DeepSeek, Claude and other GenAI tools can provide answers to most of the questions below. Before you try that, please consider the following: answering the specific questions below is not the point of this assignment. Instead, the questions are designed to give you the chance to develop a better understanding of estimation concepts and a certain level of _**statistical thinking**_. These are essential skills for any data scientist, even if they end up using generative AI - to write an effective prompt and to catch the common (often subtle) errors that AI produces when trying to solve anything non-trivial.

A very important part of this learning involves not having the answers ready-made for you, but instead taking the time to actually search for the answer, trying something, getting it wrong, and trying again.

So, make the best use of this session. The assignments are not marked, so it is much better to try the yourself even if you get incorrect answers (you'll be able to correct yourself later when you receive feedback) than to submit a perfect, but GPT'd solution.

-----

## IMPORTANT NOTES: 
- **DO NOT** change the code block names. Enter your solutions to each question into the predefined code blocks. 
- **DO NOT** add calls to `install.packages()` into your solutions. Some questions may require you to load packages using `library()`. Please do not use any other packages except the ones explicitly listed in the "setup" code block. 

---

## Setup

This code block below sets up your session. The only think you should change in it is to replace `"ABCDEFG"` by your student ID number, which will be used as the seed for your random number generators.

```{r ID, echo=FALSE, message=FALSE, warning=FALSE}
## We will use your student ID as the seed for the random number generator.
MY_STUDENT_ID <- 2701553 # <-- Replace "ABCDEFG" by your student ID number (as an integer, i.e., without quotes).
```

```{r Setup, echo=FALSE, message=FALSE, warning=FALSE}
## DO NOT CHANGE ANYTHING IN THIS CODE BLOCK

## Note: tidyverse includes:
## ggplot2, dplyr, tidyr, readr, purrr, tibble, stringr, forcats, and lubridate.
## Check https://www.tidyverse.org/packages/ for details

allowed.packages <- c("tidyverse", "readxl")

for (i in seq_along(allowed.packages)){
  if(!(allowed.packages[i] %in% installed.packages()[, 1])){
    install.packages(allowed.packages[i])
  }
  library(allowed.packages[i], character.only = TRUE)
}

knitr::opts_chunk$set(echo = TRUE, collapse=TRUE)
ignore <- runif(1) # To initialise the PRNG
```
```{r checkID, echo=FALSE}
if(!is.numeric(MY_STUDENT_ID)){
  stop("MY_STUDENT_ID MUST BE YOUR VALID NUMERIC ID.")
} 
```

## Part I: Tidy data and iteration

### Q1: Missing data and iteration

:::{#prompt .message style="color: blue;"}
**a.** Define the function called `impute_by_median` and test it using the test vector `xtest`. 
:::

```{r Q1a}
## Question 1.a
# Create a function called impute_by_median which imputes missing values based on the 
# median of the sample, rather than the mean. Test your function on the sample vector 
# provided in the solutions file. 
xtest <- c(1, 2, 3, 4, NA, 6, NA, 8, 9, 10)

# impute_by_median <- function...

impute_by_median = function(x){
  impute_med = median(x, na.rm = TRUE)  # computing median

  impute_f = function(z) {  # imputation on single element
    if (is.na(z)){
      return(impute_med)
    } else {
      return(z)
    }
  }
  return(map_dbl(x, impute_f))  # imputing across whole vector
}

xmed = impute_by_median(xtest)
xmed
```

:::{#prompt .message style="color: blue;"}
**b.** Build your data frame following the instructions in the assignment specs and store it as a data frame called `df_xy`. 
:::

```{r Q1b}
## Question 1.b

# Next, generate a data frame with two variables, x and y. Define variable x as a sequence 
# of 𝑛 values with 𝑥1 = 0, 𝑥𝑛 = 10, and 𝑥𝑖+1 = 𝑥𝑖 + 0.1, for 𝑖 = 1,...,𝑛 − 1. Variable y should 
# be set such that 𝑦𝑖 = 5𝑥𝑖 + 1. Define your data frame with those two columns and store it 
# as variable df_xy. 

x = seq(0, 10, 0.1)
y = vector()

for(i in 1:length(x)){
  y[i] = 5*x[i] + 1
}

df_xy = data.frame(x, y)
df_xy
```

:::{#prompt .message style="color: blue;"}
**c.** Define function `sometimes_missing()` and produce the dataset `df_xy_missing` following the instructions from the assignment specs.
:::

```{r}
## TWO EXAMPLES OF USING map2
library(dplyr)
library(purrr)

# Trivial example:
df_xy %>% 
  mutate(z = map2_dbl(x, y, .f = ~.x + .y)) %>%
  head(n=5) 


# A bit more complex:
# Student grades (%) per assessment of three different units
grades <- list(
  c(90, 85, 88),
  c(70, 80, 75, 85),
  c(100, 95)
)

# Assessment weights per unit
weights <- list(
  c(0.3, 0.3, 0.4),
  c(0.25, 0.25, 0.25, 0.25),
  c(0.6, 0.4)
)

# Weighted mean for each unit
map2_dbl(grades, weights, ~ sum(.x * .y))
```

```{r Q1c}
## Question 1.c

# You will use map2_dbl() to generate a new data frame with missing data. First, create a 
# function called sometimes_missing with two input arguments: index and value. The 
# function should return NA if index is divisible by 5, and return value otherwise. For 
# instance, the function should return the following outputs: 


# Defining sometimes_missing
sometimes_missing = function(index, value){
  if ((index / 5) %% 0){
  %% ret==n(NA)
  } else {
    return(value)
  }
}

sometimes_missing(15, 3)  # testing sometimes_missing
sometimes_missing(12, 3)

# x = seq(0, 10, 0.1)
y = vector()

# for(i in 1:length(x)){
#   y[i] = 5*x[i] + 1
#   if (y[i] %% 5 == 0) {
#     y[i] = NA
#   }
# }

df_xy_missing = data.frame(x, 
data.frame(
  x = x,
  y = map2_dbl(row_number(x), y, sometimes_missingsi  )n
g = data.frame(x, y)
df_xy_missing
## df_xy_missing <- ...
```

:::{#prompt .message style="color: blue;"}
**d.** Build your data frame following the instructions in the assignment specs and store it as a data frame called `df_xy_imputed`. 
:::

```{r Q1d}
## Question 1.d

# Create a new data frame df_xy_imputed by imputing all the missing values in 
# df_xy_missing$y with the median, using your function impute_by_median(). 

df_xy_imputed = impute_by_median(df_xy_missing$y)
df_xy_imputed

```

*****

### Q2: 

:::{#prompt .message style="color: blue;"}
**a.** Follow the instructions from the assignment template to load the data from `HockeyLeague.xlsx` and produce a tidy data frame called `wins_tidy`. 
:::

```{r Q2a}
## Question 2.a
library(readxl)

# folderpath = getwd()
setwd(getwd())

file_path = paste0("HockeyLeague.xlsx")

wins_data_frame = read_excel(file_path, sheet = "Wins")
losses_data_frame = read_excel(file_path, sheet = "Losses")


# Checking Dimensions
dim(wins_data_frame)
dim(losses_data_frame)

wins_data_frame = wins_data_frame %>%
  pivot_longer(
    col(wins_data_frame[1]:wins_data_frame[32]),
    names_to="year",
    values_to="integer"
  )

# Check the dimension of your resulting dataframe:
# dim(wins_tidy)

# Check the column classes:
# sapply(wins_tidy, class) ## equivalent to map_chr(wins_tidy, class)

# Check the top 4 rows:
# wins_tidy %>% print(n = 4)

```

:::{#prompt .message style="color: blue;"}
**b.** Follow the instructions from the assignment template to produce a tidy data frame called `losses_tidy`. 
:::

```{r Q2b}
## Question 2.b



# losses_tidy <- ...
```

:::{#prompt .message style="color: blue;"}
**c.** Follow the instructions from the assignment template to produce a the data frame called `hockey_df`. 
:::

```{r Q2c}
## Question 2.c



# hockey_df <- ...
```

:::{#prompt .message style="color: blue;"}
**d.** Follow the instructions from the assignment template to produce a the data frame called `summary_teams`. 
:::

```{r Q2d}
## Question 2.d


# summary_teams <- ...
```

*****

## Part II: Confidence intervals

### Q3: CIs for the Mean and Variance of a normal variable

:::{#prompt .message style="color: blue;"}
**a.** Define the function called `ci_mean_known_var` as described in the assignment specs. Test it in the vector `xtest2` defined below, using the known variance defined as `known_var`.
:::

```{r Q3a}
## Question 3.a
set.seed(MY_STUDENT_ID)                               ## <-- don't change this
known_var <- runif(1, min = 1, max = 3)               ## <-- don't change this
xtest2 <- rnorm(10, mean = 5, sd = sqrt(known_var))   ## <-- don't change this

## Your code starts below this line

# ci_mean_known_var <- function...

```

:::{#prompt .message style="color: blue;"}
**b.** Define the function called `ci_variance` as described in the assignment specs. Test it in the same vector `xtest2` defined above.
:::

```{r Q3b}
## Question 3.b


# ci_variance <- function...

```

:::{#prompt .message style="color: blue;"}
**c.** Define the function called `ci_mean_t` as described in the assignment specs. Test it in the same vector `xtest2` defined above, and contrast the interval half-widths from both cases. Can you explain why they're different?
:::

```{r Q3c}
## Question 3.c


# ci_mean_t <- function...

# an interval half-length can be calculated from a vector 'x' containing a CI using 
# diff(x) / 2.

```

:::{#prompt .message style="color: blue;"}
**d.** Build the required data frame and plot the observed differences in the half-widths of CIs obtained using your functions, as explained in the assignment specs.
:::

```{r Q3d}
## Question 3.d
set.seed(MY_STUDENT_ID) ## <-- don't change this



```

*****

## Q4: bootstrap confidence intervals

:::{#prompt .message style="color: blue;"}
**a.** Build the function `median_boot_ci` as indicated in the CW specs
:::

```{r Q4a}
## Question 4.a


```

:::{#prompt .message style="color: blue;"}
**b.** Calculate the confidence interval as indicated in the assignment specs.
:::

```{r Q4b}
## Question 4.b

# med_usd_cap_ci <- ...
```


:::{#prompt .message style="color: blue;"}
**c.** Calculate the mean and $95\%$ CI on the median %GDP spent per year on pharmaceutical drugs in OECD countries, and generate the plot as indicated in the assignment specs. 
:::

```{r Q4c}
## Question 4.c

```
